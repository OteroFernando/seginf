TimeStampToken ::= ContentInfo
-- contentType is id-signedData ([CMS])
-- content is SignedData ([CMS])

The fields of type EncapsulatedContentInfo of the SignedData
construct have the following meanings:
eContentType is an object identifier that uniquely specifies the
content type. For a time-stamp token it is defined as:
id-ct-TSTInfo OBJECT IDENTIFIER ::= { iso(1) member-body(2)
us(840) rsadsi(113549) pkcs(1) pkcs-9(9) smime(16) ct(1) 4}
eContent is the content itself, carried as an octet string.
The eContent SHALL be the DER-encoded value of TSTInfo.
The time-stamp token MUST NOT contain any signatures other than the
signature of the TSA. The certificate identifier (ESSCertID) of the
TSA certificate MUST be included as a signerInfo attribute inside a
SigningCertificate attribute.
TSTInfo ::= SEQUENCE {
version INTEGER { v1(1) },
policy TSAPolicyId,
messageImprint MessageImprint,
-- MUST have the same value as the similar field in
-- TimeStampReq
serialNumber INTEGER,
-- Time-Stamping users MUST be ready to accommodate integers
-- up to 160 bits.
genTime GeneralizedTime,
accuracy Accuracy OPTIONAL,
ordering BOOLEAN DEFAULT FALSE,
nonce INTEGER OPTIONAL,
-- MUST be present if the similar field was present
-- in TimeStampReq. In that case it MUST have the same value.
tsa [0] GeneralName OPTIONAL,
extensions [1] IMPLICIT Extensions OPTIONAL }

====================================================================================================

Time-Stamp Protocol via HTTP
This subsection specifies a means for conveying ASN.1-encoded
messages for the protocol exchanges described in Section 2 and
Appendix D via the HyperText Transfer Protocol.
Two MIME objects are specified as follows.
Content-Type: application/timestamp-query
<<the ASN.1 DER-encoded Time-Stamp Request message>>
Content-Type: application/timestamp-reply
<<the ASN.1 DER-encoded Time-Stamp Response message>>
These MIME objects can be sent and received using common HTTP
processing engines over WWW links and provides a simple browser-
server transport for Time-Stamp messages.
Upon receiving a valid request, the server MUST respond with either a
valid response with content type application/timestamp-response or
with an HTTP error.

=====================================================================================================

myPDFSigner - Instalación

1) Descargar el archivo mypdfsigner_2.7.5-1_amd64.deb
Link: https://www.kryptokoder.com/download.html (ver versión según SO)
Luego instalarlo usando: (en UBUNTU)
sudo gdebi mypdfsigner_2.7.5-1_amd64.deb

2) Hacer lo mismo para el siguiente archivo: mypdfsigner-python_2.7.5-1_amd64.deb
Link: https://www.kryptokoder.com/download.html (ver versión según SO)
Luego instalarlo usando: (en UBUNTU)
sudo gdebi mypdfsigner-python_2.7.5-1_amd64.deb


3) Creación de certificado
openssl req -newkey rsa:2048 -nodes -keyout key.pem -x509 -days 365 -out certificate.pem
openssl x509 -text -noout -in certificate.pem
openssl pkcs12 -inkey key.pem -in certificate.pem -export -out certificate.p12
openssl pkcs12 -in certificate.p12 -noout -info

Seguir todos los pasos, el nombre que definan en CN (Common Name) es el que aparece en la firma del PDF.

4) Configurar MyPDFSigner:
- Abrir myPdfSigner (la interfaz gráfica)
- Seleccionar PKCS12 KeyStore File y hacer click en Change
- Elegir el archivo .p12 que se generó cuando creamos el certificado. Ingresar la password y seleccionar un alias cualquiera del dropdown.
- Hacer click en Profile y completar con el path de la imagen. La ubicación para que aparezca al final a la derecha es: [-170 40 -40 80]. La imagen tiene que estar en formato png con color RGBA.
- Habilitar el TimeStamping escribiendo la url de la tsa. Por ahora usamos la de prueba: https://freetsa.org/tsr sin usuario ni password. Habilitarla. 
- Cerrar y verificar que se haya creado un archivo llamado .mypdfsigner en tu home.

Con eso debería poder ejecutar el código de la api del usuario con el time stamp de la free TSA y firmando con el certificado auto firmado que generamos.


